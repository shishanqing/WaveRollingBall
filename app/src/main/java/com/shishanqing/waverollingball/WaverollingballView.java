package com.shishanqing.waverollingball;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.PaintFlagsDrawFilter;import android.graphics.Path;import android.graphics.PorterDuff;import android.graphics.PorterDuffColorFilter;import android.graphics.PorterDuffXfermode;import android.graphics.Rect;import android.graphics.drawable.BitmapDrawable;import android.os.BatteryManager;import android.util.AttributeSet;import android.util.StringBuilderPrinter;import android.util.TypedValue;import android.view.View;/** * Created by Administrator on 2017/2/16. */public class WaverollingballView extends View {	private Context mContext;	private float level;	private int radius;	private int flowRadius;	private int flowColor;	private int textColor;	private int textSize;	private float FAI;	private float A;	private float W;	private float K;	private Paint mPaint;	private Paint mTextPaint;	private Path mPath;	private PaintFlagsDrawFilter mDrawFilter;	private PorterDuffXfermode mPorterDuffXfermode;	private Bitmap mBitmap;	private int mWidth;	private int mHeight;	private int mCenterX;	private int mCenterY;	private Rect mSrcRect;	private Rect mDestRect;	private Rect mTextRect;	private StringBuilder mStringBuilder;	private String isCharging;	interface OnLevelChangeListener {		int onLevelChange();	}	OnLevelChangeListener mOnLevelChangeListener;	public void setOnLevelChangeListener(OnLevelChangeListener onLevelChangeListener) {		mOnLevelChangeListener = onLevelChangeListener;	}	private BroadcastReceiver mBatteryChangeReceiver = new BroadcastReceiver() {		@Override		public void onReceive(Context context, Intent intent) {			if(Intent.ACTION_BATTERY_CHANGED.equals(intent.getAction())){				level = intent.getIntExtra("level", -1);				int curScale = intent.getIntExtra("scale", -1);				mStringBuilder.delete(0,mStringBuilder.length());				mStringBuilder.append("" + (int)level * 100 / curScale).append("%");				int status = intent.getIntExtra("status", BatteryManager.BATTERY_STATUS_UNKNOWN);				if(status == BatteryManager.BATTERY_STATUS_CHARGING) {					isCharging = getResources().getString(R.string.on_changing);				}else{					isCharging = "";				}				setA();			}		}	};	private void setA() {		if (level == 0 || level == 100) {			A = 0;		} else {			float a = -7f / 2500;			float b = -100 * a;			float c = 3;			A = (float) (a * Math.pow(level, 2) + b * level + c);		}	}	@Override	protected void onAttachedToWindow() {		super.onAttachedToWindow();		mContext.registerReceiver(mBatteryChangeReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));	}	@Override	protected void onDetachedFromWindow() {		super.onDetachedFromWindow();		mContext.unregisterReceiver(mBatteryChangeReceiver);	}	public WaverollingballView(Context context) {		this(context, null);	}	public WaverollingballView(Context context, AttributeSet attrs) {		this(context, attrs, 0);	}	public WaverollingballView(Context context, AttributeSet attrs, int defStyleAttr) {		super(context, attrs, defStyleAttr);		mContext = context;		init();		TypedArray attr = context.getTheme().obtainStyledAttributes(attrs,				R.styleable.WaverollingballView, defStyleAttr, 0);		int n = attr.getIndexCount();		for(int i = 0; i < n; i++){			int a = attr.getIndex(i);			switch (a){				case R.styleable.WaverollingballView_batteryLevel:					level = attr.getFloat(a, 0);					break;				case R.styleable.WaverollingballView_flowRadius:					flowRadius = attr.getDimensionPixelSize(a, (int) TypedValue.applyDimension(							TypedValue.COMPLEX_UNIT_DIP, 150, getResources().getDisplayMetrics()));					break;				case R.styleable.WaverollingballView_radius:					radius = attr.getInt(a, getWidth());					break;				case R.styleable.WaverollingballView_textColor:					textColor = attr.getColor(a, Color.WHITE);					break;				case R.styleable.WaverollingballView_textSize:					textSize = attr.getDimensionPixelSize(a, (int) TypedValue.applyDimension(							TypedValue.COMPLEX_UNIT_SP, 16, getResources().getDisplayMetrics()));				case R.styleable.WaverollingballView_flowViewColor:					flowColor = attr.getColor(a, 0x00FFFF);					break;				default:					break;			}		}		attr.recycle();		initPaint();		//这个线程就是为了将波浪滚动起来，改变FAI，即X轴的偏移 ,稍后完善会用属性动画实现AS		new Thread() {			@Override			public void run() {				while (true) {					changeFAI();					try {						Thread.sleep(60);					} catch (InterruptedException e) {						e.printStackTrace();					}					postInvalidate();				}			}			private void changeFAI() {				FAI += 0.2;			}		}.start();	}	private void initPaint() {		mDrawFilter = new PaintFlagsDrawFilter(0, Paint.ANTI_ALIAS_FLAG | Paint.FILTER_BITMAP_FLAG);		mPorterDuffXfermode = new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP);		mPaint = new Paint();		mPaint.setStyle(Paint.Style.FILL);		mPath = new Path();		mPaint.setAntiAlias(true);		mPaint.setDither(true);		mPaint.setFilterBitmap(true);		mPaint.setColor(getResources().getColor(R.color.flowColor));		mBitmap = ((BitmapDrawable)getResources().getDrawable(R.drawable.battery_view_bg_round)).getBitmap();		mTextPaint = new Paint();		mTextPaint.setStyle(Paint.Style.FILL);		mTextPaint.setTextAlign(Paint.Align.CENTER);		mTextRect = new Rect();		mStringBuilder = new StringBuilder();	}	private void init() {		level = 0;		radius = getWidth();		flowRadius = 150;		flowColor = 0x00FFFF;		FAI = 0;		A = 9;		W = 0.75f;		K = 0;	}	@Override	protected void onDraw(Canvas canvas) {		canvas.setDrawFilter(mDrawFilter);		//新开启一个图层，用于绘制波浪		int sc = canvas.saveLayer(0 + getPaddingLeft(), 0 + getPaddingTop(), mWidth - getPaddingRight(), mHeight - getPaddingBottom(), null,				Canvas.ALL_SAVE_FLAG);		//清除上次的path		mPath.reset();/*		level = 0;		setA();		//setK();*/		//利用正弦曲线方程 Y = A sin(wx+FAI)+k，将计算后的坐标传入Path.quadTo()方法（绘制贝塞尔曲线）中,构建波浪曲线。		for (int x = mDestRect.left; x < mDestRect.right; x++) {			float y = (float) (A * Math.sin(Math.PI / 250 * W * x + FAI) + K + (mDestRect.bottom - mDestRect.top)					* 1.0f / 100 * (100 - level));			if (x == mDestRect.left) {				mPath.moveTo(x, y);			}			mPath.quadTo(x, y, x + 1, y);		}		//将Path连结起来,形成闭环		mPath.lineTo(mDestRect.right, mDestRect.bottom);		mPath.lineTo(mDestRect.left, mDestRect.bottom);		mPath.close();		//绘制波浪图形(图形上部是波浪，下部是矩形) （DST）		canvas.drawPath(mPath, mPaint);		//设置遮罩模式(图像混合模式)		mPaint.setXfermode(mPorterDuffXfermode);		//绘制用于遮罩的圆形 (SRC)		canvas.drawBitmap(mBitmap, mSrcRect, mDestRect, mPaint);		//设置遮罩模式为null		mPaint.setXfermode(null);		//将这个新图层绘制的bitmap，与上一个图层合并(显示)		canvas.restoreToCount(sc);		//canvas.restore(); 也可以		//绘制电池电量		canvas.drawText(mStringBuilder.toString(), mCenterX, mCenterY,mTextPaint);		//绘制电量文字的 字体大小和颜色		canvas.drawText(isCharging, mCenterX, mCenterY + 50,mTextPaint);		mTextPaint.setTextSize(24);	}	@Override	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {		setMeasuredDimension(measuredWidth(widthMeasureSpec), measuredHeight(heightMeasureSpec));	}	private int measuredHeight(int heightMeasureSpec) {		//初始化weight的默认值为150dp		int measuredHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 150, getResources().getDisplayMetrics());		//得到测量模式和测量值		int specMode = MeasureSpec.getMode(heightMeasureSpec);		int specSize = MeasureSpec.getSize(heightMeasureSpec);		//如果是确定的值或Match_parent		if (MeasureSpec.EXACTLY == specMode) {			measuredHeight = specSize;		} else {			//取默认值和测量值的最小值			measuredHeight = Math.min(specSize, measuredHeight);		}		return measuredHeight;	}	private int measuredWidth(int widthMeasureSpec) {		int measuredWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 150, getResources().getDisplayMetrics());		int specMode = MeasureSpec.getMode(widthMeasureSpec);		int specSize = MeasureSpec.getSize(widthMeasureSpec);		if (MeasureSpec.EXACTLY == specMode) {			measuredWidth = specSize;		} else {			measuredWidth = Math.min(specSize, measuredWidth);		}		return measuredWidth;	}	@Override	protected void onSizeChanged(int w, int h, int oldw, int oldh) {		mWidth = w;		mHeight = h;		mCenterX = w / 2;		mCenterY = h / 2;		mSrcRect = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());		/*mDestRect = new Rect(mCenterX - flowRadius, mCenterY - flowRadius,				mCenterX + flowRadius, mCenterY + flowRadius);*/		//这边遮罩在绘制时应该考虑View的padding，		mDestRect = new Rect(0 + getPaddingLeft(), 0 + getPaddingTop(), mWidth - getPaddingRight(), mHeight - getPaddingBottom());		//mDestRect = new Rect(mWidth/2-flowRadius, mHeight/2-flowRadius,mWidth/2+flowRadius ,  mHeight/2+flowRadius);	}}